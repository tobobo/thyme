{
  "name": "result-core",
  "version": "1.2.0",
  "description": "minimal result reification",
  "keywords": [
    "result",
    "promise",
    "future"
  ],
  "dependencies": {
    "inherit": "nathan7/inherit#f1a75b4844",
    "next-tick": "timoxley/next-tick#0.0.2",
    "result-type": "1.0.0"
  },
  "devDependencies": {
    "serve": "jkroso/serve",
    "chai-spies": "*",
    "hydro-html": "*",
    "hydro-chai": "*",
    "hydro-bdd": "*",
    "hydro-dot": "*",
    "hydro": "*",
    "chai": "*",
    "jsmd": "*",
    "tryc": "*"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jkroso/result-core.git"
  },
  "bugs": {
    "url": "https://github.com/jkroso/result-core/issues"
  },
  "author": {
    "name": "Jake Rosoman"
  },
  "license": "MIT",
  "files": [
    "index.js"
  ],
  "readme": "\n# result-core\n\nJavaScript doesn't allow you to spawn new threads. Nore does it allow you to park a thread programmatically. Instead it uses an \"event loop\", which functions as a sort of work queue. It allows you to request an operation and register a function to be called when its completed. This function is called a \"callback\" and it provides all the synchronization we need to compose computations however it leaves our control flow model FUBAR. Normally we think of values and errors as propagating up and down an implicit call stack. When a child computation completes it is returned to its parent frame where it can be passed into other computation frames or simply ignored and allowed to propagate up the stack. Meanwhile, in the \"event loop\" model values/errors are passed in to the callbacks as arguments which means both that they never become available in the parent context and that they can't just be allowed to propagate. Also without callstack's our error objects are mostly garbage.\n\nResults are an attempt to re-build the call stack conceptual model back on top of the \"event loop\" model. The approach they take is to ask you to reify your asynchronous function calls with a Result instance. The intention of these is to model stack frames, in that they will eventually be either a successfully computed value or an error. Because these Result instances are runtime objects you can compose them together to recreate the computation tree that is normally implicit and maintained underneath the runtime.\n\nThis implementation does nothing to improve the stack traces of your errors but that feature could be added.\n\n## Installation\n\nWith your favorite package manager:\n\n- [packin](//github.com/jkroso/packin): `packin add result-core`\n- [component](//github.com/component/component#installing-packages): `component install jkroso/result-core`\n- [npm](//npmjs.org/doc/cli/npm-install.html): `npm install result-core`\n\nthen in your app:\n\n```js\nvar Result = require('result-core')\n```\n\n## API\n\n### Result()\n\nA class for creating concrete representations of function calls which can be manipulated programmatically at run-time.\n\n### Result.state\n\nThe state of the result. Can be one of:\n\n- pending\n- done\n- fail\n\nAll Results start of in a \"pending\" state and will transition either to \"done\" or \"fail\".\n\n```js\nnew Result().state // => 'pending'\n```\n\n### Result.value\n\nThe value of the Result. If the Result has a state of \"fail\" then this value is an error. If its \"pending\" then reading its value is useless. You should use the read method unless you know what your doing and are handling each of the 3 possible states correctly.\n\n```js\nfunction add(a, b){\n  var result = new Result\n  result.write(a + b)\n  return result\n}\n\nadd(1, 2).value // => 3\n```\n\n### Result#write(value)\n\ngive the Result its value and change its state to \"done\"\n\n```js\nvar one = new Result().write(1)\none.state // => 'done'\none.value // => 1\n```\n\n### Result#error(reason)\n\n  give the Result its error and change its state to \"fail\"\n\n```js\nvar err = new Error('coz oops')\nvar two = new Result().error(err)\ntwo.state // => 'fail'\ntwo.value // => err\n```\n\n### Result#read([onValue], [onError])\n\n  access the result of `this`\n\n```js\none.read(function(n){\n  n // => 1\n}) // error handlers are optional\ntwo.read(\n  null, // value handlers are also optional\n  function(e){\n    e // => err\n  })\n```\n",
  "readmeFilename": "Readme.md",
  "homepage": "https://github.com/jkroso/result-core",
  "_id": "result-core@1.2.0",
  "dist": {
    "shasum": "a629ced02feb70a4825c65cd4f5b11fe69ff294a"
  },
  "_from": "result-core@1.2.0",
  "_resolved": "https://registry.npmjs.org/result-core/-/result-core-1.2.0.tgz"
}
